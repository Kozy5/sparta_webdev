CS 핵심 용어 / 간단 용어정리!

(CS 적 의미는 차이가 있지만 큰틀에서는 비슷한 의미로 이해할 수 있는 용어)

● 프로세스 = 프로그램을 실행해주는 주체 ex) 카카오톡을 실행함

● 쓰레드   = 작업을 처리해주는 주체     ex) 메세지 발송을 처리해줌

# CPU를 잘 사용하기 위해 프로세스를 잘 배정해야 함

● CPU는 한정된 자원으로 최대의 성능이 중요!
그렇기에 CPU를 적절하고 효율적으로 사용해야함

● ex) OS는 실행 대기중인 프로그램(프로세스)들에게 
CPU자원 배정을 적절히 하여 시스템의 성능을 끌어올릴 수 있다.
(결국 처리는 CPU!)

● 공통배정조건 : 오버헤드↓ / 사용률↑ / 기아 현상↓
    ● 오버헤드: 프로세스가 자원낭비 못하게
    ● 사용률: 프로세스가 최대한 자원 많이받아 빠른 처리
    ● 기아 현상 : 프로세스가 자원 못 받고 배고픈상태로 대기하지 않게
    
● 목표에 따른 배정조건 :
1. 배치 시스템 : 가능하면 많은 일을 수행. / 시간(time)보다 처리량(throughout)이 중요 
2. 대화형 시스템 : 빠른 응답 시간(time) / 적은 대기시간이 중요
3. 실시간 시스템 : 실시간(time)즉, 최소 응답시간(dead line)중요

● 정책에 따라 3가지로 나뉨
1. CPU이용률을 최대화
2. 오버헤드를 최소화
3. 모든프로세스가 공평하게 분배 




1. 스케쥴링(CS 면접 단골 질문)

1-1 스케쥴링 소개

1-1-1. 스케쥴링의 단위
! Cycle !
● CPU Burst 
- # 프로세스 사용중에 연속적으로 CPU를 사용하는 구간을의미(실제 CPU를 사용하는 스케쥴링 단위)
● I/O Burst
- # 프로세스 실행에서 I/O 작업이 끝날때까지 CPU사용이 Block되는 구간을 의미 

1-1-2. 스케쥴링 알고리즘 평가기준
2-1. CPU이용률    : 전체 시스템 시간 중, CPU가 작업을 처리하는 시간의 비율
2-2. 처리량       : CPU가 단위 시간당 처리하는 프로세스의 개수
2-3. 총 처리 시간 : 프로세스가 시작해서 끝날때까지 걸린 시간
2-4. 대기 시간    : 프로세스가 준비완료 큐에서 대기하는 시간의 총 합
2-5. 응답시간     : 대화식 시스템에서 요청 후 첫 응답이 오기까지 걸린 시간



1-2 스케쥴링 종류
# 선점 스케쥴링(Preemptive Scheduling)
OS가 CPU의 사용권을 선점할 수 있는 경우
강제 회수하는 경우 (처리 시간 예측 어려움),
(OS가 나서서 CPU사용권을 '선점'하고, 
특정 요건에 따라 각 프로세스의 
요청이 있을 때 프로세스에게 분배하는 방식)

● 가장 자원이 필요한 프로세스에게 CPU를 분배, 상황에 따라 강제로 회수함

● 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합 / 긴급 프로세스 제어 가능 
(대화식 시분할 시스템에서는 꾸준하면서 최대한 빠른 응답을 줘야하는게 관건이기때문에 CPU상황마다
CPU사용권에 대해 최우선 처리를 하는게 좋기때문이라고 보여진다.)

1-2-1. 선점1 Priority Scheduling(우선순위 스케쥴링) 기아문제 에이징으로 해결

특징
1. 정적/동적으로 우선순위를 부여하여 우선순위각 높은 순서대로 처리
2. 우선 순위가 낮은 프로세스가 무한정 기다리는 기아 현상 발생 가능
3. Aging 방법으로 기아현상 문제 해결 가능
미리 주어진 프로세의 우선순위에 따라 스케쥴링하는 방식
(SJF(Shortest Job First Scheduling) 도 Priorty Scheduling의 일종)

● 하지만 단점으로 우선순위가 낮은 프로세스는 할당되지 않기도 한다.(기아(Starvarion)현상)
● 이를 방지하기 위한 해결법으로 노화(Aging)이 있다.(기다리는 시간에 따라 우선순위 증가 방식)
-> 우선순위가 같을시 FCFS(First Come Fist Served)를 적용

[스케쥴링 예시]
프로세스  버스트 시간 우선 순위 턴어라운드 시간 대기 시간
  P1         10          3           16          6            
  P2          1          1           1           0            
  P3          2          4           18          16            
  P4          1          5           19          18            
  P5          5          2           6           1   
  평균        -          -           12          8.2   
/P2/    P5     /         P1        /   P3  /P4/

예시에서 알 수 있는 정보
1. 버스트 시간     : 가장 짧은것 -> 처음과 끝
2. 우선순위        : 다음으로 짧은것-> 맨뒤부터, 가장 긴것-> 맨앞부터, 순서대로
3. 턴어라운드 시간 : 앞 순 버스트시간 + 자기 버스트 시간
4. 대기시간        : 앞 순의 버스트시간의 합 or 턴어라운드시간 - 자기버스트시간    

1-2-2 선점2 Round Robin(라운드로빈) 시간 할당량 / 준비완료큐의말단서재할당대기(순환큐)

# FCFS에 의해 프로세스들이 보내지면 
각 프로세스는 동일한 시간의 Time Quantum만큼 할당

정해진 시간 할당량 만큼 프로세스를 할당한 뒤, 
작업이 끝난 프로세스는 준비완료 큐(순한 큐)의  //준비완료 큐가 뭘까
가장 마지막에 가서 재할당을 기다리는 방법입니다.(회전식) 

● 시간 할당량이 중요
# 너무 작으면 =  빈번한 문맥 전환(Context Switching)이 발생
# 너무 길면   =  FCFS와 다를 바 없어짐
[스케쥴링 예시]
시간 할당량 3ms
프로세스  도착 시간 버스트 시간 턴어라운드 시간 대기 시간
  P1          0          5           14          6            
  P2          1          3           5           0            
  P3          2          8           20          16            
  P4          1          6           17          18      
  평균        -          -           14          8.5
/P1 /P2 /P3 /P4 /P1/P3 /P5 /P3/
 3  6  9  12 14 17 20 22  

1-2-3 Multilevel-Queue(다단계 큐)
# 준비완료 큐를 여러개의 큐로 분류해 
- 각 큐가 각각 다른 스케쥴링 알고리즘을 가지는 방식
- 메모리 크기, 우선순위, 유형 등 프로세스 특성에 따라
  하나의 큐에 영구적으로 할당 됨
- 따라서 큐와 큐 사이에도 스케쥴링이 필요
- 우선순위 방식 or 시분할 방식으로 함

1. 우선순위 방식
# 고정 우선순위의 선점형 방식으로 구현, 
따라서 우선순위에 따른 큐의 스케쥴링은 절대적임
[예시] 
1-1 우선순위가 높은 Forground Queue
● 대화형 프로세스를 위한 큐
● Roung Robin

1-2 우선순위가 낮은 Background Queue
● 연산작업을 처리하는 프로세스 큐
● FCFS

-> Forground큐가 비어있지 않는 한!
Background큐는 먼저 실행될 수 없음!
Background큐가 먼저 실행중이라도!
Forground큐에 프로세스가 들어오면 선점됨!